# UART

## UART란?
- **Universal Asynchronous Receiver/Transmitter**의 약자.
- **비동기 직렬 통신**: 송신/수신이 공유 클럭 없이 미리 합의한 속도(baud)에 맞춰 비트를 주고받으며, 데이터 프레임 앞뒤에 Start/Stop 비트를 붙여 타이밍을 맞춘다.
- 기본 배선: **TX(송신)**, **RX(수신)**, **GND** 3선이면 동작(하드웨어 플로우 제어 쓰면 RTS/CTS 추가).
- **전이중 통신 (Full-Duplex):** **송신(TX, Transmit)**과 **수신(RX, Receive)**을 위한 라인이 분리되어 있어 데이터의 송신과 수신이 동시에 일어날 수 있다.
- **1:1 통신 (Point-to-Point):** 기본적으로 두 개의 장치 간의 1:1 통신을 위해 설계되었다.
- 보드 내부 SoC의 UART 주변장치(레지스터) + 핀 2개로 이루어짐. 라인 드라이버(예: RS-232/RS-485 변환기)는 선택.

---

## 신호와 프레임 구조
```text
Idle(1)  Start(0)  D0  D1  D2  D3  D4  D5  D6  D7  [Parity]  Stop(1)
            ↓      LSB 먼저 전송                                     ↑
```
- **Idle**: 유휴 상태(논리 1). 여기서 1→0으로 떨어지는 에지를 **Start bit**로 인식.
  - RS-232는 신호가 반전되어 Idle이 음전압(논리 1)임.
- **Start bit**(시작 신호, 1비트): 통신 시작을 알리기 위해 라인을 LOW 상태로 1비트만큼 내림.
- **Data bit**(보통 5~8비트, 실제 전송 데이터): 실제 데이터 (보통 7~8비트)를 전송.
- **Parity bit**(오류 검증용 비트, 선택사항): 데이터 비트의 1의 개수를 세어 오류를 검출.  
  - **Even Parity**: 데이터와 패리티 비트의 1의 개수가 짝수가 되도록 설정.  
  - **Odd Parity**: 1의 개수가 홀수가 되도록 설정.  
  - **None**: 패리티 비트 사용 안 함.
- **Stop bit**(종료 신호, 1~2비트): 통신 종료를 알리기 위해 라인을 다시 HIGH 상태로 1~2비트만큼 올림.

---

## 핵심 설정
- Baudrate: 초당 심볼(비트) 수. 9600, 115200, 921600…
    - 비동기라 송수신 클럭 오차 허용이 작음(대략 ±2% 내외 권장).
- Data bits: 7/8/9.
- Parity: N(없음)/E/O.
- Stop bits: 1 / 1.5 / 2.
- Flow control:
  - None: 가장 단순.
  - RTS/CTS(하드웨어): 버퍼 꽉 차면 자동으로 멈춤/재개.
  - **XON/XOFF(소프트웨어)**: 제어문자 `XON`(0x11, DC1)과 `XOFF`(0x13, DC3)를 사용해 데이터 흐름을 제어.
- 오버샘플링: UART 내부에서 각 비트를 8× 또는 16×로 샘플링해 안정화.
- **레지스터 설정 공식(예시)**: `divisor = f_periph / (oversample * baud)`  
  - `f_periph`: UART 모듈에 공급되는 주변 클럭 주파수.
  - `oversample`: 일반적으로 8x 또는 16x(제조사 및 설정에 따라 다름).
  - **주의**: 제조사별로 공식 및 레지스터 설정 방식이 다를 수 있으니 데이터시트를 참조.

---

## UART 주요 사용처

- 디버그 콘솔/로그: 부트로더, 커널 earlyprintk, 펌웨어 로그(115200-8N1 고정이 많음).
- 모듈 제어: GPS(NMEA 0183 4800/9600bps), 블루투스 HC-05, LTE/5G 모뎀(AT 커맨드), Wi-Fi(ESP8266/ESP32 AT).
- 산업 현장: RS-485 + Modbus RTU, PLC/인버터/서보 드라이브 설정/모니터링.
- 무대조명/방송: DMX512(250k, 8N2 기반) – RS-485 전기적 규격.
- 로봇/임베디드 보드 간 통신: 보드 간 간단한 메시지 교환, 센서/액추에이터와 포인트-투-포인트 연결.
- 부트로더/펌웨어 업데이트: 간단한 프로토콜로 안정적 전달.

---

## 장/단점

| 구분 | 내용
|:---:|:---|
| 장점 | - 배선이 단순(최소 3선), 구현이 쉬움.<br>- OS 없이도 빠르게 bring-up(부트 로그, printf 대체). <br>- 긴 호환 역사(도구, 어댑터 풍부).
| 단점 | - 주소 개념 없음(기본 UART는 포인트투포인트) → 멀티드롭은 RS-485 같은 물리 계층 추가 필요. <br>- 공유 클럭이 없어 보레이트 오차와 노이즈에 민감. <br>- 에러 검출이 약함(대개 패리티/프레이밍 수준, CRC는 상위 프로토콜에서 처리). <br>- TTL 레벨은 거리 제한 큼(장거리엔 부적합).

---

## 비동기 vs 동기 통신

- **비동기(UART)**: 별도의 클럭 라인 없이 Start/Stop 비트로 동기화. 배선 단순, 설정 쉬움.
- **동기(SPI/I2C)**: 클럭 라인으로 타이밍 동기화 → SPI는 전이중·고속·선 많음, I²C는 2선(SCL/SDA)·주소화·저속·다슬레이브에 적합장.

## 비교표
| 항목 | UART | I²C | SPI
|:---|:---:|:---:|:---:
| 기본구조 | 비동기(클럭 없음) | 동기(클럭 있음, SCL) | 동기(클럭 있음, SCLK)
| 신호/배선 | TX, RX(+GND). 필요시 RTS/CTS | SCL(클럭), SDA(데이터)(+GND) | SCK, MOSI, MISO, CS(+GND)
| 통신방식 | 1:1 Point-to-Point | 다수 마스터·슬레이브(멀티드롭) | 마스터 1 : 슬레이브 N
| Duplex | 전이중 Full-duplex | 반이중 Half-duplex | 전이중 Full-duplex
| 주소/프레이밍 | 주소 개념 없음(상위 프로토콜) | 7/10비트 주소, ACK/NACK | 주소 없음, CS로 슬레이브 선택
| 속도 | 수 kbps ~ 수 Mbps(일반 TTL) | 100k/400k/1M/3.4M(일반) | 수 MHz ~ 수십 MHz(보드 내)
| 전송거리 | 길다(수 m~수십 m) | 짧다(수십 cm~수 m) | 매우 짧다(수십 cm 내외)
| 멀티슬레이브 | 불가능 | 쉬움 | 복잡함 (CS 핀 x 슬레이브 수)
| 대표 용도 | 디버그 콘솔, 모뎀/모듈 제어, PC-칩, 부트로더 | 센서·EEPROM·디스플레이 저속 제어 | 플래시/SD, 디스플레이, 고속 센서/ADC, 스트리밍
